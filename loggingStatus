Structuuroverzicht

Gebruik @Lob (Large object) voor de logs datamodel

1. JobExecution entity (vereenvoudigd)

@Entity
public class JobExecution {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String jobName;
    private String nodeId;
    private String status;
    private String logs;

    private Instant startTime;
    private Instant endTime;

    // getters/setters
}

2. De JobExecutionRepository

@Repository
public interface JobExecutionRepository extends JpaRepository<JobExecution, Long> {
    Optional<JobExecution> findByJobName(String jobName);
}


⸻

Fabric8-achtergrond: log ophalen van een Pod

Je haalt logs op met:

InputStream logStream = client.pods()
    .inNamespace(namespace)
    .withName(podName)
    .inContainer("main")
    .getLogInputStream();

En leest dat uit met een BufferedReader.

⸻

Complete flow: Watcher + Log Capture + Opslag

In je JobServiceImpl

@Service
@RequiredArgsConstructor
public class JobExecutionServiceImpl implements JobExecutionService {

    private static final Logger log = LoggerFactory.getLogger(JobExecutionServiceImpl.class);

    private final KubernetesClient client;
    private final JobExecutionRepository jobExecutionRepository;

    @Value("${kubernetes.client.namespace}")
    private String namespace;

    @Override
    public void executeRunScript(RunScriptRequestDto dto) {
        String jobName = dto.getJobName();
        String nodeId = dto.getNodeId();

        Job job = buildJobFromDto(dto); // ← jouw bestaande jobbuilder

        // Voeg label toe aan job om pod herkenbaar te maken
        job.getMetadata().getLabels().putIfAbsent("job-name", jobName);

        client.batch().v1().jobs()
              .inNamespace(namespace)
              .resource(job)
              .create();

        JobExecution execution = new JobExecution();
        execution.setId(UUID.randomUUID()); // tenzij @GeneratedValue wordt gebruikt
        execution.setJobName(jobName);
        execution.setNodeId(nodeId);
        execution.setStartTime(Instant.now());
        execution.setStatus("RUNNING");

        jobExecutionRepository.save(execution);

        // Wacht kort op pod voordat watcher start
        waitForPodAndStartWatcher(jobName, execution);
    }

    private void waitForPodAndStartWatcher(String jobName, JobExecution execution) {
        final int maxAttempts = 10;
        final int delayMillis = 500;

        for (int i = 0; i < maxAttempts; i++) {
            PodList podList = client.pods()
                                    .inNamespace(namespace)
                                    .withLabel("job-name", jobName)
                                    .list();

            if (podList != null && !podList.getItems().isEmpty()) {
                String podName = podList.getItems().get(0).getMetadata().getName();
                log.info("Pod {} gevonden voor job {}", podName, jobName);
                watchPodAndCaptureLogs(podName, execution);
                return;
            }

            try {
                Thread.sleep(delayMillis);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                log.error("Watcher start onderbroken", e);
                return;
            }
        }

        log.warn("Geen pod gevonden voor job {} na {} pogingen", jobName, maxAttempts);
        execution.setStatus("POD_NOT_FOUND");
        execution.setEndTime(Instant.now());
        execution.setLogOutput("Pod is niet gevonden voor job: " + jobName);
        jobExecutionRepository.save(execution);
    }

    private void watchPodAndCaptureLogs(String podName, JobExecution execution) {
        client.pods()
              .inNamespace(namespace)
              .withName(podName)
              .watch(new Watcher<>() {
                  @Override
                  public void eventReceived(Action action, Pod pod) {
                      String phase = pod.getStatus().getPhase();
                      log.info("Pod {} in fase {}", podName, phase);

                      if ("Succeeded".equals(phase) || "Failed".equals(phase)) {
                          try {
                              String logOutput = captureLogs(podName);
                              execution.setLogOutput(logOutput);
                              execution.setStatus(phase.toUpperCase());
                              execution.setEndTime(Instant.now());
                              jobExecutionRepository.save(execution);
                              log.info("Log voor job {} opgeslagen ({} bytes)", execution.getJobName(), logOutput.length());
                          } catch (IOException e) {
                              log.error("Fout bij log ophalen van pod {}", podName, e);
                              execution.setStatus("LOG_ERROR");
                              execution.setEndTime(Instant.now());
                              execution.setLogOutput("Log ophalen mislukt: " + e.getMessage());
                              jobExecutionRepository.save(execution);
                          }
                      }
                  }

                  @Override
                  public void onClose(WatcherException e) {
                      log.warn("Watcher gesloten voor pod {}: {}", podName, e.getMessage());
                  }
              });
    }

    private String captureLogs(String podName) throws IOException {
        InputStream logStream = client.pods()
            .inNamespace(namespace)
            .withName(podName)
            .inContainer("main") // pas aan als je container een andere naam heeft
            .getLogInputStream();

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(logStream))) {
            return reader.lines().collect(Collectors.joining("\n"));
        }
    }
}


⸻

Tips voor productie

Onderdeel	Advies
getLogInputStream()	Gebruik try-with-resources om memory leaks te voorkomen
Lange logs	Overweeg logs op te slaan als bestand op PVC bij > 5000+ regels
Foutafhandeling	Zorg voor fallback status = "LOG_FAILED" als lezen faalt
Tijdslimiet	Voeg optioneel een timeout of ExecutorService toe
Clean-up	Laat jobs automatisch verwijderen met ttlSecondsAfterFinished


⸻

Bonus: Inline scripts ondersteunen?

Wil je inline scripts ook loggen? Dan geef je in RunScriptRequestDto bijv.:

{
  "jobName": "inline-xyz",
  "nodeId": "inline_1",
  "inlineScript": "print('hello world')"
}

En dan zet je in je job een command zoals:

.withCommand("python", "-c", dto.getInlineScript())

Log capturing blijft hetzelfde.

⸻
