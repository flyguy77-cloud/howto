Zorg dat je setNodes altijd een array returnt, ook als er niks hoeft te veranderen:

Fout voorbeeld:
setNodes((prev) => {
  if (!gitlabFiles.length) return; // Geen return value ‚Üí undefined
  return prev.map(...);
});

Goed voorbeeld:
setNodes((prev) => {
  if (!gitlabFiles.length) return prev; // Altijd array teruggeven
  return prev.map(...);
});

useEffect(() => {
  if (!Array.isArray(nodes) || nodes.length === 0) return;

  setNodes((prev) => {
    if (!Array.isArray(prev)) return [];

    return prev.map((node) => {
      if (node.type !== "loadscript") return node;

      const fields = node.data?.fields;
      const integration = fields?.[0]?.integration;
      const gitlab = integration?.[0]?.gitlab;
      const file = gitlab?.[0]?.file;

      if (!file?.id) {
        return {
          ...node,
          data: {
            ...node.data,
            fields: [
              {
                ...fields?.[0],
                integration: [
                  {
                    ...integration?.[0],
                    gitlab: [
                      {
                        ...gitlab?.[0],
                        file: {
                          ...(file || {}),
                          present: false, // geen geldig script geselecteerd
                        },
                      },
                    ],
                  },
                ],
              },
            ],
          },
        };
      }

      // Check of file.id bestaat in GitLab
      const exists = gitlabFiles.some((f) => f.id === file.id);

      return {
        ...node,
        data: {
          ...node.data,
          fields: [
            {
              ...fields?.[0],
              integration: [
                {
                  ...integration?.[0],
                  gitlab: [
                    {
                      ...gitlab?.[0],
                      file: {
                        ...file,
                        present: exists, // true als file-id in lijst zit
                      },
                    },
                  ],
                },
              ],
            },
          ],
        },
      };
    });
  });
}, [gitlabFiles, nodes, setNodes]);

=======

Ja, het is prima dat je dit doet:

return (
  <Flow
    nodes={nodes}
    edges={edges}
    setNodes={setNodes}
    setEdges={setEdges}
    onNodesChange={onNodesChange}
  />
);

Maar dan moet je onNodesChange w√©l in Editor.tsx defini√´ren (zoals je hierboven doet) √©n met de juiste useCallback. Dus:
	‚Ä¢	nodes leeft in Editor.tsx
	‚Ä¢	setNodes leeft in Editor.tsx
	‚Ä¢	onNodesChange leeft ook in Editor.tsx, want die heeft directe toegang tot setNodes
	‚Ä¢	Flow is ‚Äúdumb‚Äù en krijgt alles als props

‚∏ª

Waarom dit logisch is

Flow is een puur presentatiecomponent in jouw architectuur. De echte businesslogica (waar de state wordt beheerd, zoals validatie via useValidateGitlabFiles) gebeurt in Editor.tsx. Dat betekent:
	‚Ä¢	Editor.tsx is de source of truth voor nodes
	‚Ä¢	setNodes moet dus daar blijven
	‚Ä¢	Alle handlers die setNodes gebruiken, zoals onNodesChange, moeten ook daar leven

‚∏ª

Wat je moet vermijden

Je wil niet dat Flow.tsx zelf een eigen setNodes() gaat doen, of lokale state heeft zoals:

const [nodes, setNodes] = useState<Node[]>([]);

Want dan zitten je Editor.tsx en Flow.tsx op twee verschillende bronnen van waarheid, en dat breekt je app z√©ker als je complexe flows (zoals validatie of synchronisatie met de backend) gebruikt.

‚∏ª

Dus de correcte, professionele opzet is:

Editor.tsx:

const [nodes, setNodes] = useState<Node[]>([]);
const [edges, setEdges] = useState<Edge[]>([]);

const { gitlabFiles, isLoading } = useValidateGitlabFiles(nodes, setNodes);

const onNodesChange = useCallback(
  (changes: NodeChange[]) => {
    setNodes((prev) => applyNodeChanges(changes, prev));
  },
  []
);

return (
  <Flow
    nodes={nodes}
    edges={edges}
    setNodes={setNodes}
    setEdges={setEdges}
    onNodesChange={onNodesChange}
  />
);

Flow.tsx:

const Flow = ({ nodes, edges, setNodes, setEdges, onNodesChange }) => {
  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      // eventueel onEdgesChange of onConnect
    />
  );
};

useEffect(() => {
  if (!gitlabFiles || gitlabFiles.length === 0) return;
  if (!nodes || nodes.length === 0) return;

  setNodes((prevNodes) => {
    let updated = false;

    const validatedNodes = prevNodes.map((node) => {
      if (node.type !== "loadscript") return node;

      const file = node.data?.fields?.integration?.gitlab?.file;
      const exists = gitlabFiles.some((f) => f.id === file?.id);

      const present = !!file?.id && exists;

      // Check of er daadwerkelijk iets veranderd is
      if (file?.present !== present) {
        updated = true;

        return {
          ...node,
          data: {
            ...node.data,
            fields: {
              ...node.data.fields,
              integration: {
                ...node.data.fields.integration,
                gitlab: {
                  ...node.data.fields.integration.gitlab,
                  file: {
                    ...file,
                    present
                  }
                }
              }
            }
          }
        };
      }

      return node;
    });

    return updated ? validatedNodes : prevNodes; // üí• voorkomt loop
  });
}, [gitlabFiles]); // üëà Alleen afhankelijk van gitlabFiles

export const Flow = ({ nodes, edges, setNodes, setEdges }: FlowProps) => {
  const onNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes((prevNodes) => applyNodeChanges(changes, prevNodes));
    },
    [setNodes]
  );

  const onEdgesChange = useCallback(
    (changes: EdgeChange[]) => {
      setEdges((prevEdges) => applyEdgeChanges(changes, prevEdges));
    },
    [setEdges]
  );

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      fitView
    />
  );
};

type FlowProps = {
  nodes: Node[];
  setNodes: React.Dispatch<React.SetStateAction<Node[]>>;
  edges: Edge[];
  setEdges: React.Dispatch<React.SetStateAction<Edge[]>>;
};

export const Flow = ({ nodes, setNodes, edges, setEdges }: FlowProps) => {
  const onNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes((prevNodes) => applyNodeChanges(changes, prevNodes));
    },
    [setNodes]
  );

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      const type = event.dataTransfer.getData("application/reactflow");
      const position = { x: event.clientX, y: event.clientY };
      const newId = getNextNodeId(nodes);

      const newNode: Node = {
        id: newId,
        type,
        position,
        data: {
          fields: {
            integration: {
              gitlab: {
                file: {},
              },
            },
          },
        },
      };

      setNodes((prev) => [...prev, newNode]);
    },
    [nodes, setNodes]
  );

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onDrop={onDrop}
      ...
    />
  );
};



