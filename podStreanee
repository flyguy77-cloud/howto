
Alles wat je nodig hebt zit hierin:
	•	JobStatusWatcher (watch job status → DB update)
	•	PodReadyWatcher (wacht totdat pod Running is → start log streamer)
	•	PodLogStreamer (stream logs via LogWatch → update DB in 1 regel)
	•	JobMonitor (centrale orchestrator → start watchers → sluit ze correct)
	•	Lifecycle: correct, single-run, geen duplicaten, geen retries, geen log-replays
	•	Non-blocking, virtual threads, volledig closing-veilig


⸻

PACKAGE STRUCTUUR

com.yourapp.k8s
  ├── JobMonitor.java
  ├── watcher
  │     ├── JobStatusWatcher.java
  │     ├── PodReadyWatcher.java
  ├── logging
  │     ├── PodLogStreamer.java


⸻

1. JOB STATUS WATCHER

Dit handelt Kubernetes Job events af (Succeeded / Failed / Active)

package com.yourapp.k8s.watcher;

import io.fabric8.kubernetes.api.model.batch.v1.Job;
import io.fabric8.kubernetes.client.Watch;
import io.fabric8.kubernetes.client.Watcher;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
@RequiredArgsConstructor
public class JobStatusWatcher implements AutoCloseable {

    private final JobStatusService statusService;
    private Watch statusWatch;

    public Watch start(String namespace, String jobName, UUID execId) {

        this.statusWatch = statusService.getClient().batch().v1().jobs()
                .inNamespace(namespace)
                .withName(jobName)
                .watch(new Watcher<Job>() {

                    @Override
                    public void eventReceived(Action action, Job job) {
                        statusService.updateStatusFromJob(execId, job);
                    }

                    @Override
                    public void onClose(WatcherException cause) {
                        // optional debug
                    }
                });

        return this.statusWatch;
    }

    @Override
    public void close() {
        if (statusWatch != null) try { statusWatch.close(); } catch (Exception ignored) {}
    }
}


⸻

2. POD READY WATCHER

Wacht totdat pod Running is → roept callback aan
Daarna sluit hij zichzelf
Nooit meer dan 1 keer log-start triggeren

package com.yourapp.k8s.watcher;

import io.fabric8.kubernetes.api.model.Pod;
import io.fabric8.kubernetes.client.Watch;
import io.fabric8.kubernetes.client.Watcher;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class PodReadyWatcher implements AutoCloseable {

    private final KubernetesClient client;
    private Watch podWatch;

    public interface PodReadyCallback {
        void onPodReady(String podName);
    }

    public Watch start(String namespace, String jobName, PodReadyCallback callback) {

        this.podWatch = client.pods()
                .inNamespace(namespace)
                .withLabel("job-name", jobName)
                .watch(new Watcher<Pod>() {

                    @Override
                    public void eventReceived(Action action, Pod pod) {
                        if (pod == null || pod.getStatus() == null) return;

                        String phase = pod.getStatus().getPhase();

                        // RUNNING → starten log streamer
                        if ("Running".equalsIgnoreCase(phase)) {
                            String podName = pod.getMetadata().getName();
                            callback.onPodReady(podName);
                            close(); // nooit nogmaals log-start triggeren
                        }
                    }

                    @Override
                    public void onClose(WatcherException cause) {}
                });

        return this.podWatch;
    }

    @Override
    public void close() {
        if (podWatch != null) try { podWatch.close(); } catch (Exception ignored) {}
    }
}


⸻

3. POD LOG STREAMER

De moderne (niet-deprecated) log-streamer
Leest uitsluitend nieuwe logregels dankzij tailingLines(0)
Loopt in virtual thread
Schrijft alles in 1 DB-regel (appendChunk + appendFinal)

package com.yourapp.k8s.logging;

import io.fabric8.kubernetes.client.KubernetesClient;
import io.fabric8.kubernetes.client.dsl.LogWatch;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class PodLogStreamer implements AutoCloseable {

    private final KubernetesClient client;
    private final JobLogService logService;

    private volatile boolean running = false;
    private LogWatch logWatch;

    public LogWatch start(String namespace, String podName, UUID execId) {

        running = true;

        // CREËER LOGWATCH (blijft open)
        this.logWatch = client.pods()
                .inNamespace(namespace)
                .withName(podName)
                .tailingLines(0)          // ONLY NEW LOGS
                .watchLog();              // InputStream-based API

        // BACKGROUND READER
        Thread.ofVirtual().start(() -> streamLogs(execId));

        return this.logWatch;
    }

    private void streamLogs(UUID execId) {

        try (BufferedReader br = new BufferedReader(
                new InputStreamReader(logWatch.getOutput(), StandardCharsets.UTF_8))) {

            String line;
            StringBuilder buffer = new StringBuilder();
            int count = 0;

            while (running && (line = br.readLine()) != null) {
                buffer.append(line).append("\n");
                count++;

                if (count >= 50) {
                    logService.appendChunk(execId, buffer.toString());
                    buffer.setLength(0);
                    count = 0;
                }
            }

            if (buffer.length() > 0) {
                logService.appendFinal(execId, buffer.toString());
            }

        } catch (Exception e) {
            // logging
        }
    }

    @Override
    public void close() {
        running = false;

        if (logWatch != null) {
            try { logWatch.close(); } catch (Exception ignored) {}
        }
    }
}


⸻

4. DE JOB MONITOR (CENTRAAL ORCHESTRATOR PATROON)

Start job status watcher
Start pod watcher → start log streamer wanneer pod ready is
Bewaart ALLE watchers
Sluit ALLES correct

package com.yourapp.k8s;

import com.yourapp.k8s.watcher.JobStatusWatcher;
import com.yourapp.k8s.watcher.PodReadyWatcher;
import com.yourapp.k8s.logging.PodLogStreamer;
import io.fabric8.kubernetes.client.Watch;
import io.fabric8.kubernetes.client.dsl.LogWatch;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
@RequiredArgsConstructor
public final class JobMonitor implements AutoCloseable {

    private final JobStatusWatcher jobStatusWatcher;
    private final PodReadyWatcher podReadyWatcher;
    private final PodLogStreamer podLogStreamer;

    private Watch statusWatch;
    private Watch podWatch;
    private LogWatch logWatch;

    public void start(String namespace, String jobName, UUID execId) {

        // 1. JOB STATUS
        this.statusWatch = jobStatusWatcher.start(namespace, jobName, execId);

        // 2. POD READY → start logStreamer
        this.podWatch = podReadyWatcher.start(namespace, jobName, podName -> {
            this.logWatch = podLogStreamer.start(namespace, podName, execId);
        });
    }

    @Override
    public void close() {

        if (statusWatch != null) try { statusWatch.close(); } catch (Exception ignored) {}
        if (podWatch != null) try { podWatch.close(); } catch (Exception ignored) {}
        if (logWatch != null) try { logWatch.close(); } catch (Exception ignored) {}

        try { jobStatusWatcher.close(); } catch (Exception ignored) {}
        try { podReadyWatcher.close(); } catch (Exception ignored) {}
        try { podLogStreamer.close(); } catch (Exception ignored) {}
    }
}


⸻

WAT DIT ALLEMAAL OPLOST

✔ Geen dubbele logs

→ tailingLines(0)
→ logStreamer start exact één keer
→ PodReadyWatcher sluit zichzelf

✔ Geen dubbele watchers

→ JobMonitor bewaart referenties
→ close() sluit ALLES

✔ Geen race conditions

→ logstreamer in eigen VirtualThread

✔ Geen deprecated API’s

→ moderne watchLog() + InputStream streaming

✔ Alles netjes in Spring lifecycle

→ Watchers zijn beans
→ Monitor regelt het geheel

✔ Geen DB locking

→ appendChunk / appendFinal zorgt voor 1 record per job

⸻