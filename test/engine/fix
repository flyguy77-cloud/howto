Stap-voor-stap fix (minimale impact)

Stap 1 ‚Äî Controllers mogen alleen DTO‚Äôs gebruiken

DIT is verplicht

Fout:

@PostMapping
public WorkflowEntity create(@RequestBody WorkflowEntity wf) {
    return repo.save(wf);
}

Goed:

@PostMapping
public WorkflowDto create(@RequestBody WorkflowDto dto) {
    WorkflowEntity wf = repo.save(dto.toEntity());
    return WorkflowDto.fromEntity(wf);
}

Swagger ziet nu WorkflowDto, niet de entity-boom.

‚∏ª

Stap 2 ‚Äî DTO‚Äôs zijn plat (geen back-references)

WorkflowDto

public record WorkflowDto(
        UUID id,
        String name,
        List<NodeDto> nodes,
        List<EdgeDto> edges,
        ScheduleConfigDto schedule
) {}

NodeDto

public record NodeDto(
        String nodeId,
        NodeKind kind,
        NodeType type,
        Map<String, Object> config
) {}

NOOIT dit doen in DTO:

WorkflowDto workflow;   // veroorzaakt recursion


‚∏ª

Stap 3 ‚Äî Entities blijven bidirectioneel (dat is OK)

Je hoeft je entities niet te veranderen.

@Entity
public class WorkflowEntity {

    @OneToMany(mappedBy = "workflow", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<NodeEntity> nodes = new ArrayList<>();
}

@Entity
public class NodeEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    private WorkflowEntity workflow;
}

Dat is correct JPA-modeling
Het probleem ontstaat pas bij JSON-serialisatie

‚∏ª

Stap 4 ‚Äî Geen @JsonIgnore, geen @JsonManagedReference

Die lossen Swagger symptomen op maar:
	‚Ä¢	breken lazy loading
	‚Ä¢	maken je API onvoorspelbaar
	‚Ä¢	veroorzaken andere bugs later

Gebruik ze niet.

‚∏ª

Waarom DTO‚Äôs dit 100% oplossen

Swagger werkt zo:

Controller signature ‚Üí ObjectMapper ‚Üí JSON schema

Als Swagger alleen DTO‚Äôs ziet:
	‚Ä¢	geen entity graph
	‚Ä¢	geen circular references
	‚Ä¢	geen nested explosion
	‚Ä¢	‚úî duidelijke API contracten



==========================

NodeDto mag een toNodeEntity() hebben,
maar mag NOOIT zelf bepalen bij welke workflow hij hoort.

Dus:
‚úîÔ∏è mappinglogica in DTO ‚Üí prima
‚ùå parent-relatie (workflow) in DTO ‚Üí niet doen

Ik laat je nu exact zien hoe dit er netjes uitziet met:
	‚Ä¢	toNodeEntity()
	‚Ä¢	fromNodeEntity()
	‚Ä¢	zonder NOT NULL issues
	‚Ä¢	zonder rommel in Swagger
	‚Ä¢	zonder DDD-regels te breken

‚∏ª

1Ô∏è‚É£ NodeDto met toNodeEntity() en fromNodeEntity()

public record NodeDto(
        String nodeId,
        NodeKind kind,
        NodeType type,
        Map<String, Object> config
) {

    /** DTO ‚Üí Entity (ZONDER workflow!) */
    public WorkflowNodeEntity toNodeEntity() {
        WorkflowNodeEntity e = new WorkflowNodeEntity();
        e.setNodeId(this.nodeId);
        e.setKind(this.kind);
        e.setType(this.type);
        e.setConfigJson(JsonUtils.toJson(this.config));
        return e;
    }

    /** Entity ‚Üí DTO */
    public static NodeDto fromNodeEntity(WorkflowNodeEntity e) {
        return new NodeDto(
                e.getNodeId(),
                e.getKind(),
                e.getType(),
                JsonUtils.fromJson(e.getConfigJson())
        );
    }
}

üîë Belangrijk
	‚Ä¢	Geen workflow
	‚Ä¢	Geen workflowId
	‚Ä¢	Geen constructor met workflow
	‚Ä¢	Alleen node-eigen data

‚∏ª

2Ô∏è‚É£ EdgeDto met toEdgeEntity() / fromEdgeEntity()

public record EdgeDto(
        String edgeId,
        String fromNodeId,
        String toNodeId
) {

    public WorkflowEdgeEntity toEdgeEntity() {
        WorkflowEdgeEntity e = new WorkflowEdgeEntity();
        e.setEdgeId(this.edgeId);
        e.setFromNodeId(this.fromNodeId);
        e.setToNodeId(this.toNodeId);
        return e;
    }

    public static EdgeDto fromEdgeEntity(WorkflowEdgeEntity e) {
        return new EdgeDto(
                e.getEdgeId(),
                e.getFromNodeId(),
                e.getToNodeId()
        );
    }
}


‚∏ª

3Ô∏è‚É£ WorkflowRequestDto blijft simpel

public record WorkflowRequestDto(
        String name,
        List<NodeDto> nodes,
        List<EdgeDto> edges,
        ScheduleConfigDto schedule
) {}


‚∏ª

4Ô∏è‚É£ WorkflowEntity (aggregate root)

@Entity
public class WorkflowEntity {

    @Id
    @GeneratedValue
    private UUID id;

    private String name;

    @Embedded
    private ScheduleConfigEmbeddable schedule;

    @OneToMany(
            mappedBy = "workflow",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private List<WorkflowNodeEntity> nodes = new ArrayList<>();

    @OneToMany(
            mappedBy = "workflow",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private List<WorkflowEdgeEntity> edges = new ArrayList<>();

    public void addNode(WorkflowNodeEntity node) {
        node.setWorkflow(this);     // üî• parent wordt HIER gezet
        nodes.add(node);
    }

    public void addEdge(WorkflowEdgeEntity edge) {
        edge.setWorkflow(this);
        edges.add(edge);
    }
}


‚∏ª

5Ô∏è‚É£ Workflow save-flow (DIT lost je probleem op)

public WorkflowEntity toEntity(WorkflowRequestDto dto) {

    WorkflowEntity wf = new WorkflowEntity();
    wf.setName(dto.name());

    if (dto.schedule() != null) {
        wf.setSchedule(mapSchedule(dto.schedule()));
    }

    for (NodeDto nodeDto : dto.nodes()) {
        WorkflowNodeEntity node = nodeDto.toNodeEntity(); // ‚úîÔ∏è toegestaan
        wf.addNode(node);                                 // üî• parent hier
    }

    for (EdgeDto edgeDto : dto.edges()) {
        WorkflowEdgeEntity edge = edgeDto.toEdgeEntity();
        wf.addEdge(edge);
    }

    return wf;
}

--------------------------------->>>>>>>>>

‚úÖ Dit moet je doen ‚Äî expliciet, maar centraal
public WorkflowEntity toWorkflowEntity() {

    WorkflowEntity wf = new WorkflowEntity();
    wf.setName(this.name());

    // NODES
    for (NodeDto nodeDto : nodes) {
        WorkflowNodeEntity node = nodeDto.toNodeEntity();
        wf.addNode(node); // üî• hier wordt workflow gezet
    }

    // EDGES
    for (EdgeDto edgeDto : edges) {
        WorkflowEdgeEntity edge = edgeDto.toEdgeEntity();
        wf.addEdge(edge);
    }

    return wf;
}

En WorkflowEntity:
public void addNode(WorkflowNodeEntity node) {
    node.setWorkflow(this);
    this.nodes.add(node);
}

üëâ Als je ook maar √©√©n keer setNodes(...) gebruikt ‚Üí bingo, bug.

/////////////////
