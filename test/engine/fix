Swagger serializeert JPA entities met bidirectionele relaties,
waardoor Workflow ‚Üí Node ‚Üí Workflow ‚Üí Node ‚Üí ‚Ä¶ ontstaat.

Dat is onvermijdelijk zolang Swagger entities ziet.

‚∏ª

De enige structureel juiste oplossing

Swagger mag NOOIT entities zien. Alleen DTO‚Äôs.

Alles daarbuiten is een workaround, geen oplossing.

‚∏ª

Stap-voor-stap fix (minimale impact)

Stap 1 ‚Äî Controllers mogen alleen DTO‚Äôs gebruiken

DIT is verplicht

Fout:

@PostMapping
public WorkflowEntity create(@RequestBody WorkflowEntity wf) {
    return repo.save(wf);
}

Goed:

@PostMapping
public WorkflowDto create(@RequestBody WorkflowDto dto) {
    WorkflowEntity wf = repo.save(dto.toEntity());
    return WorkflowDto.fromEntity(wf);
}

Swagger ziet nu WorkflowDto, niet de entity-boom.

‚∏ª

Stap 2 ‚Äî DTO‚Äôs zijn plat (geen back-references)

WorkflowDto

public record WorkflowDto(
        UUID id,
        String name,
        List<NodeDto> nodes,
        List<EdgeDto> edges,
        ScheduleConfigDto schedule
) {}

NodeDto

public record NodeDto(
        String nodeId,
        NodeKind kind,
        NodeType type,
        Map<String, Object> config
) {}

NOOIT dit doen in DTO:

WorkflowDto workflow;   // veroorzaakt recursion


‚∏ª

Stap 3 ‚Äî Entities blijven bidirectioneel (dat is OK)

Je hoeft je entities niet te veranderen.

@Entity
public class WorkflowEntity {

    @OneToMany(mappedBy = "workflow", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<NodeEntity> nodes = new ArrayList<>();
}

@Entity
public class NodeEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    private WorkflowEntity workflow;
}

Dat is correct JPA-modeling
Het probleem ontstaat pas bij JSON-serialisatie

‚∏ª

Stap 4 ‚Äî Geen @JsonIgnore, geen @JsonManagedReference

Die lossen Swagger symptomen op maar:
	‚Ä¢	breken lazy loading
	‚Ä¢	maken je API onvoorspelbaar
	‚Ä¢	veroorzaken andere bugs later

Gebruik ze niet.

‚∏ª

Waarom DTO‚Äôs dit 100% oplossen

Swagger werkt zo:

Controller signature ‚Üí ObjectMapper ‚Üí JSON schema

Als Swagger alleen DTO‚Äôs ziet:
	‚Ä¢	geen entity graph
	‚Ä¢	geen circular references
	‚Ä¢	geen nested explosion
	‚Ä¢	‚úî duidelijke API contracten

@Entity
public class WorkflowEntity {

    @Id
    @GeneratedValue
    private UUID id;

    private String name;

    @Embedded
    private ScheduleConfigEmbeddable schedule;

    @OneToMany(
            mappedBy = "workflow",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private List<WorkflowNodeEntity> nodes = new ArrayList<>();

    @OneToMany(
            mappedBy = "workflow",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private List<WorkflowEdgeEntity> edges = new ArrayList<>();

    public void addNode(WorkflowNodeEntity node) {
        node.setWorkflow(this);     // parent wordt HIER gezet
        nodes.add(node);
    }

    public void addEdge(WorkflowEdgeEntity edge) {
        edge.setWorkflow(this);
        edges.add(edge);
    }
}

public WorkflowEntity toEntity(WorkflowRequestDto dto) {

    WorkflowEntity wf = new WorkflowEntity();
    wf.setName(dto.name());

    if (dto.schedule() != null) {
        wf.setSchedule(mapSchedule(dto.schedule()));
    }

    for (NodeDto nodeDto : dto.nodes()) {
        WorkflowNodeEntity node = nodeDto.toNodeEntity(); // ‚úîÔ∏è toegestaan
        wf.addNode(node);                                 // üî• parent hier
    }

    for (EdgeDto edgeDto : dto.edges()) {
        WorkflowEdgeEntity edge = edgeDto.toEdgeEntity();
        wf.addEdge(edge);
    }

    return wf;
}
