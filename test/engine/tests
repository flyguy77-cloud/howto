WorkflowServiceImpl tests

@Test
void update_updatesExistingNodeByNodeKey() {
    UUID workflowId = UUID.randomUUID();

    WorkflowNodeEntity existingNode = new WorkflowNodeEntity();
    existingNode.setNodeKey("node-A");

    WorkflowEntity wf = new WorkflowEntity();
    wf.setName("old");
    wf.addNode(existingNode);

    when(workflowRepo.findById(workflowId)).thenReturn(Optional.of(wf));

    NodeDto dtoNode = new NodeDto("node-A");
    WorkflowRequestDto dto = new WorkflowRequestDto(
            "new-name",
            null,
            List.of(dtoNode)
    );

    service.update(workflowId, dto);

    // assertions
    assertThat(wf.getName()).isEqualTo("new-name");
    assertThat(wf.getNodes()).hasSize(1);

    WorkflowNodeEntity resultNode = wf.getNodes().get(0);
    assertThat(resultNode).isSameAs(existingNode); // ðŸ‘ˆ GEEN nieuwe entity
    assertThat(resultNode.getNodeKey()).isEqualTo("node-A");
    assertThat(resultNode.getWorkflow()).isSameAs(wf);

    verify(workflowRepo).findById(workflowId);
}

@Test
void update_addsNewNodeWhenNodeKeyDoesNotExist() {
    UUID workflowId = UUID.randomUUID();

    WorkflowEntity wf = new WorkflowEntity();
    when(workflowRepo.findById(workflowId)).thenReturn(Optional.of(wf));

    NodeDto dtoNode = new NodeDto("node-new");

    WorkflowRequestDto dto = new WorkflowRequestDto(
            "wf",
            null,
            List.of(dtoNode)
    );

    service.update(workflowId, dto);

    assertThat(wf.getNodes()).hasSize(1);

    WorkflowNodeEntity node = wf.getNodes().get(0);
    assertThat(node.getNodeKey()).isEqualTo("node-new");
    assertThat(node.getWorkflow()).isSameAs(wf);
}

@Test
void update_removesNodesNotPresentInDto() {
    UUID workflowId = UUID.randomUUID();

    WorkflowNodeEntity nodeA = new WorkflowNodeEntity();
    nodeA.setNodeKey("A");

    WorkflowNodeEntity nodeB = new WorkflowNodeEntity();
    nodeB.setNodeKey("B");

    WorkflowEntity wf = new WorkflowEntity();
    wf.addNode(nodeA);
    wf.addNode(nodeB);

    when(workflowRepo.findById(workflowId)).thenReturn(Optional.of(wf));

    // DTO bevat alleen node A
    WorkflowRequestDto dto = new WorkflowRequestDto(
            "wf",
            null,
            List.of(new NodeDto("A"))
    );

    service.update(workflowId, dto);

    assertThat(wf.getNodes())
            .hasSize(1)
            .allMatch(n -> n.getNodeKey().equals("A"));
}

@Test
void update_doesNotDependOnIdsInDto() {
    UUID workflowId = UUID.randomUUID();

    WorkflowEntity wf = new WorkflowEntity();
    when(workflowRepo.findById(workflowId)).thenReturn(Optional.of(wf));

    WorkflowRequestDto dto = new WorkflowRequestDto(
            "wf",
            null,
            List.of(new NodeDto("X"))
    );

    service.update(workflowId, dto);

    verify(workflowRepo).findById(workflowId);
    verifyNoMoreInteractions(workflowRepo);
}

================

workflowScheduleRegistrar

@Test
void syncSchedule_deletesRecurringJob_whenScheduleIsNull() {
    UUID workflowId = UUID.randomUUID();

    WorkflowEntity wf = new WorkflowEntity();
    wf.setId(workflowId);
    wf.setSchedule(null);

    registrar.syncSchedule(wf);

    verify(jobScheduler).delete("workflow-" + workflowId);
    verifyNoMoreInteractions(jobScheduler);
    verifyNoInteractions(executionService);
}

@Test
void syncSchedule_deletesRecurringJob_whenScheduleIsDisabled() {
    UUID workflowId = UUID.randomUUID();

    ScheduleConfig schedule = new ScheduleConfig();
    schedule.setEnabled(false);

    WorkflowEntity wf = new WorkflowEntity();
    wf.setId(workflowId);
    wf.setSchedule(schedule);

    registrar.syncSchedule(wf);

    verify(jobScheduler).delete("workflow-" + workflowId);
    verifyNoMoreInteractions(jobScheduler);
    verifyNoInteractions(executionService);
}

@Test
void syncSchedule_schedulesRecurringJob_whenScheduleIsEnabled() {
    UUID workflowId = UUID.randomUUID();

    ScheduleConfig schedule = new ScheduleConfig();
    schedule.setEnabled(true);
    schedule.setCron("0 0 * * *");

    WorkflowEntity wf = new WorkflowEntity();
    wf.setId(workflowId);
    wf.setSchedule(schedule);

    ArgumentCaptor<Runnable> jobCaptor = ArgumentCaptor.forClass(Runnable.class);

    registrar.syncSchedule(wf);

    verify(jobScheduler).scheduleRecurrently(
            eq("workflow-" + workflowId),
            eq("0 0 * * *"),
            jobCaptor.capture()
    );

    // ðŸ‘‰ simuleer JobRunr trigger
    jobCaptor.getValue().run();

    verify(executionService).startExecution(workflowId);
}

@Test
void syncSchedule_doesNotDelete_whenScheduleIsEnabled() {
    UUID workflowId = UUID.randomUUID();

    ScheduleConfig schedule = new ScheduleConfig();
    schedule.setEnabled(true);
    schedule.setCron("* * * * *");

    WorkflowEntity wf = new WorkflowEntity();
    wf.setId(workflowId);
    wf.setSchedule(schedule);

    registrar.syncSchedule(wf);

    verify(jobScheduler, never()).delete(any());
}
