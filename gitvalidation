1. Types definiëren (types/workflow.ts)

export type GitlabFile = {
  id: string;
  name: string;
  path: string;
};

export type NodeData = {
  fields: {
    integration: {
      gitlab: {
        file?: GitlabFile & { present?: boolean };
      };
    };
  };
};


⸻

2. Nieuwe hook useValidateGitlabFiles

import { useQuery } from "@tanstack/react-query";
import { useEffect } from "react";
import client from "../api/client";
import { Node } from "@xyflow/react";
import { GitlabFile, NodeData } from "../types/workflow";

export const useValidateGitlabFiles = (
  nodes: Node<NodeData>[],
  setNodes: React.Dispatch<React.SetStateAction<Node<NodeData>[]>>
) => {
  // 1. Haal bestanden op uit GitLab
  const { data: gitlabFiles = [], isLoading } = useQuery<GitlabFile[]>({
    queryKey: ["gitlab-files"],
    queryFn: async () => {
      const res = await client.get<GitlabFile[]>("/api/gitlab/files");
      return res.data;
    },
    staleTime: 60_000,
  });

  // 2. Valideer automatisch bij nieuwe data
  useEffect(() => {
    if (!gitlabFiles.length) return;

    setNodes((prevNodes) =>
      prevNodes.map((node) => {
        if (node.type !== "loadscript") return node;

        const file = node.data?.fields?.integration?.gitlab?.file;

        // Als geen file gekozen is → markeer als niet aanwezig
        if (!file || !file.id) {
          return {
            ...node,
            data: {
              ...node.data,
              fields: {
                ...node.data.fields,
                integration: {
                  ...node.data.fields.integration,
                  gitlab: {
                    ...node.data.fields.integration.gitlab,
                    file: { ...(file || {}), present: false },
                  },
                },
              },
            },
          };
        }

        // Check of file-id voorkomt in GitLab → update "present"
        const exists = gitlabFiles.some((f) => f.id === file.id);

        return {
          ...node,
          data: {
            ...node.data,
            fields: {
              ...node.data.fields,
              integration: {
                ...node.data.fields.integration,
                gitlab: {
                  ...node.data.fields.integration.gitlab,
                  file: { ...file, present: exists },
                },
              },
            },
          },
        };
      })
    );
  }, [gitlabFiles, setNodes]);

  return { gitlabFiles, isLoading };
};


⸻

3. Gebruik in Editor.tsx

const [nodes, setNodes] = useState<Node<NodeData>[]>([]);

// Haal data op en valideer automatisch
const { gitlabFiles, isLoading } = useValidateGitlabFiles(nodes, setNodes);

if (isLoading) {
  return <p>GitLab bestanden worden geladen...</p>;
}


⸻

Hoe de automatische validatie werkt
	•	Trigger: useQuery haalt gitlabFiles op.
	•	Effect: Zodra gitlabFiles verandert → useEffect runt automatisch.
	•	Actie: Elke node met type "loadscript" krijgt zijn file.present-flag geüpdatet.
	•	Resultaat:
	•	Geen losse invalidNodes meer nodig.
	•	Je ziet in de UI direct welke scripts niet meer bestaan.

⸻

Waarom dit beter is dan je oude code

Aspect	Oude hook	Nieuwe hook
Validatie	Handmatig filteren	Automatisch updaten per node
Resultaat	Return invalidNodes	Geen losse state, node zelf bevat status
Typing	Impliciet / any	Volledig getypeerd
Trigger	Handmatig	Automatisch via useEffect


⸻--------------------------------------------------------

1. Verplaats de validatie zelf ook naar de hook

Je hebt nu de useEffect in de Editor.tsx staan.
Beter is om de hook volledig verantwoordelijk te maken voor het updaten van present, zodat de Editor “dom” blijft.

Aangepaste hook

// hooks/useValidateGitlabFiles.ts
import { useQuery } from "@tanstack/react-query";
import { useEffect } from "react";
import client from "../api/client";
import { Node } from "@xyflow/react";

type GitlabFile = {
  id: string;
  name: string;
  path: string;
};

export const useValidateGitlabFiles = (
  nodes: Node[],
  setNodes: React.Dispatch<React.SetStateAction<Node[]>>
) => {
  // 1. Haal bestanden op
  const { data: gitlabFiles = [], isLoading } = useQuery<GitlabFile[]>({
    queryKey: ["gitlab-files"],
    queryFn: async () => {
      const res = await client.get("/api/gitlab/files");
      return res.data;
    },
    staleTime: 60000,
  });

  // 2. Valideer automatisch bij nieuwe data
  useEffect(() => {
    if (!gitlabFiles) return;

    setNodes((prevNodes) =>
      prevNodes.map((node) => {
        if (node.type !== "loadscript") return node;

        const file = node.data?.fields?.integration?.gitlab?.file;

        // Als er geen file gekozen is → altijd invalid
        if (!file || !file.id) {
          return {
            ...node,
            data: {
              ...node.data,
              fields: {
                ...node.data.fields,
                integration: {
                  ...node.data.fields.integration,
                  gitlab: {
                    ...node.data.fields.integration.gitlab,
                    file: { ...(file || {}), present: false },
                  },
                },
              },
            },
          };
        }

        // Als file-id niet voorkomt in GitLab → invalid
        const exists = gitlabFiles.some((f) => f.id === file.id);

        return {
          ...node,
          data: {
            ...node.data,
            fields: {
              ...node.data.fields,
              integration: {
                ...node.data.fields.integration,
                gitlab: {
                  ...node.data.fields.integration.gitlab,
                  file: { ...file, present: exists },
                },
              },
            },
          },
        };
      })
    );
  }, [gitlabFiles, setNodes]);

  return { gitlabFiles, isLoading };
};


⸻

2. Editor.tsx wordt simpeler

const { nodes, setNodes } = useReactFlow();

const { gitlabFiles, isLoading } = useValidateGitlabFiles(nodes, setNodes);

// Geen extra useEffect meer nodig


⸻

3. BaseNode.tsx toont validatie

const file = node.data.fields.integration.gitlab.file;

return (
  <Box>
    <Typography variant="body2">{file?.name || "Geen script geselecteerd"}</Typography>

    {!file?.present && (
      <Typography color="error" variant="caption">
        ❌ Script bestaat niet meer in GitLab
      </Typography>
    )}
  </Box>
);


⸻

4. Voordelen van deze aanpak
	•	Editor.tsx is “dom” → geen logica meer.
	•	Hook doet alles → ophalen + valideren + state bijwerken.
	•	BaseNode toont alleen UI-feedback.
	•	Het wordt eenvoudiger om later dezelfde validatie ook bij save of workflow reload toe te passen.

⸻

Volgende stap

Omdat je straks ook nog het RunScript node wil koppelen aan de LoadScript nodes, kan ik je adviseren om de validatiestatus (present) mee te nemen in je save-API.
Zo kun je ook server-side controleren of iemand een script probeert te draaien dat niet meer bestaat.
