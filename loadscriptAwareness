ðŸ”¹ Doelstelling
	1.	Scenario: Workflow wordt opnieuw geladen in het canvas.
	2.	Elke LoadScript-node bevat een opgeslagen GitLab-script (id, name, path).
	3.	Je wilt bij het laden controleren:
	â€¢	Bestaat het script nog in GitLab?
	â€¢	Zo niet, toon een visuele waarschuwing in de node.
	4.	Je hebt al:
	â€¢	GET /api/gitlab/files â†’ lijst met alle scripts
	â€¢	GET /api/gitlab/file/:id â†’ metadata + content van Ã©Ã©n script

â¸»

ðŸ”¹ Aanpak

Stap 1 â€” Validatieveld toevoegen aan de LoadScript-node

We voegen een nieuw veld aan node.data toe, bijvoorbeeld:

data: {
  fields: {
    integration: {
      gitlab: {
        file: {
          id: "123",
          name: "setup.sh",
          path: "scripts/setup.sh"
        },
        valid: true,      // âœ… default: geldig
        missing: false    // âŒ wordt true als file niet meer bestaat
      }
    }
  }
}


â¸»

Stap 2 â€” Validatiehook voor GitLab-files

We maken een hook die alle scripts uit GitLab ophaalt en gebruikt om de validatie te doen:

import { useQuery } from "@tanstack/react-query";
import client from "../api/client";

export const useValidateGitlabFiles = (nodes: Node[]) => {
  const { data: gitlabFiles = [], isLoading } = useQuery({
    queryKey: ["gitlab-files"],
    queryFn: async () => {
      const res = await client.get("/api/gitlab/files");
      return res.data; // array met { id, name, path }
    },
    staleTime: 60000 // cache 1 min
  });

  const invalidNodes = nodes
    .filter((node) => node.type === "loadscript")
    .filter((node) => {
      const file = node.data.fields?.integration?.gitlab?.file;
      return file && !gitlabFiles.some((f: any) => f.id === file.id);
    });

  return { invalidNodes, gitlabFiles, isLoading };
};


â¸»

Stap 3 â€” Integratie in je canvas of editorpagina

In je Editor-pagina waar je de workflow laadt:

const { invalidNodes, isLoading } = useValidateGitlabFiles(nodes);

useEffect(() => {
  if (!isLoading && invalidNodes.length > 0) {
    invalidNodes.forEach((node) => {
      console.warn(
        `Script ${node.data.fields.integration.gitlab.file.name} ontbreekt in GitLab`
      );
    });
  }
}, [invalidNodes, isLoading]);


â¸»

Stap 4 â€” Visuele feedback in de LoadScript-node

Pas je LoadScriptNode.tsx aan om visueel te laten zien dat het script ontbreekt:

export const LoadScriptNode = ({ data }) => {
  const file = data.fields.integration.gitlab.file;
  const isMissing = data.fields.integration.gitlab.missing;

  return (
    <div style={{ border: isMissing ? "2px solid red" : "1px solid gray" }}>
      <h4>Load Script</h4>
      {file ? (
        <>
          <div>ðŸ“„ {file.name}</div>
          {isMissing && <span style={{ color: "red" }}>Script ontbreekt in GitLab!</span>}
        </>
      ) : (
        <span style={{ color: "gray" }}>Geen script geselecteerd</span>
      )}
    </div>
  );
};


â¸»

Stap 5 â€” Automatisch updaten van de node-status

Wanneer een script ontbreekt, kun je via je bestaande updateField-methode automatisch het missing-veld op true zetten:

invalidNodes.forEach((node) => {
  updateField(node.id, "fields.integration.gitlab.missing", true);
});


â¸»

ðŸ”¹ Samenvattend

Stap	Wat je doet	Resultaat
1. Node uitbreiden	missing of valid flag toevoegen	Node kan status opslaan
2. Hook maken	useValidateGitlabFiles(nodes)	Controleert of files bestaan
3. Integreren	In Editor gebruiken	Automatische validatie bij load
4. UI aanpassen	Rode warning / errorborder bij ontbrekend script	Direct visueel inzicht
5. State updaten	updateField gebruiken	Node-data blijft synchroon


---------

Hoofddoel

De RunScript-node moet:
Weten welke LoadScript-nodes eraan gekoppeld zijn
â†’ via edges op de canvas.
Script-informatie ophalen
â†’ script id, name, path van LoadScript-node.
Script-content ophalen
â†’ via backend, maar niet tonen.
Variabelen kunnen injecteren
â†’ per gekoppelde node custom variabelen opslaan.
Alles opslaan in node.data
â†’ zodat later backend-executie makkelijk wordt.
 

**Eerste stappen**

Stap 1 â€” Maak de RunScript-node â€œawareâ€ van zijn gekoppelde nodes

Je hebt in je canvas een state met nodes en edges.
We gebruiken reactflow â†’ useReactFlow() om edges op te vragen.
import { useReactFlow } from "reactflow";

const useLinkedLoadScripts = (runScriptNodeId: string) => {
  const { getEdges, getNodes } = useReactFlow();

  return React.useMemo(() => {
    // Zoek alle edges waar de RunScript-node de target is
    const linkedEdges = getEdges().filter(
      (edge) => edge.target === runScriptNodeId
    );

    // Haal de gekoppelde LoadScript-nodes op
    return getNodes().filter((node) =>
      linkedEdges.some((edge) => edge.source === node.id && node.type === "loadscript")
    );
  }, [getEdges, getNodes, runScriptNodeId]);
};

Resultaat:
De hook useLinkedLoadScripts(runScriptNodeId) geeft je alle gekoppelde LoadScript-nodes terug.
 

Stap 2 â€” Script-informatie uit die nodes halen

Elke LoadScript-node bevat in node.data.fields.integration.gitlab.file de info over het script:
const linkedScripts = linkedLoadScriptNodes.map((node) => ({
  id: node.data.fields.integration.gitlab.file.id,
  name: node.data.fields.integration.gitlab.file.name,
  path: node.data.fields.integration.gitlab.file.path,
}));
Deze lijst van scripts kun je nu opslaan in je RunScript-node via je bestaande updateField-functie:
updateField("linkedScripts", linkedScripts);
 

Stap 3 â€” Backend endpoint voor content ophalen

Maak in je backend een endpoint om meerdere scripts in Ã©Ã©n call op te halen:
POST /api/gitlab/scripts/content

Request body:
{
  "scripts": [
    { "id": "123", "path": "scripts/setup.sh" },
    { "id": "456", "path": "scripts/deploy.sh" }
  ]
}

Response:
[
  {
    "id": "123",
    "name": "setup.sh",
    "content": "#!/bin/bash\necho setup"
  },
  {
    "id": "456",
    "name": "deploy.sh",
    "content": "#!/bin/bash\necho deploy"
  }
]
 

Stap 4 â€” Script-content ophalen in RunScript-node (onzichtbaar)

Maak een hook useFetchScriptContents:
const useFetchScriptContents = (scripts: { id: string; path: string }[]) => {
  const [loading, setLoading] = React.useState(false);
  const [contents, setContents] = React.useState([]);

  React.useEffect(() => {
    if (!scripts.length) return;

    const fetchContent = async () => {
      setLoading(true);
      try {
        const res = await client.post("/api/gitlab/scripts/content", { scripts });
        setContents(res.data);
      } finally {
        setLoading(false);
      }
    };

    fetchContent();
  }, [scripts]);

  return { contents, loading };
};
Je kunt deze hook gebruiken in de RunScript-node om stilletjes de script-content alvast te cachen.
 

Stap 5 â€” Variabelen per script injecteren

In je RunScript-node UI kun je voor elk gekoppeld script een variabelenformulier maken:
updateField("variables", {
  [scriptId]: { ENV: "prod", REGION: "eu-west" }
});
Deze variabelen stuur je later samen met het script mee naar de backend-executie.
 

Structuur in node.data

Voor een RunScript-node ziet node.data er straks zo uit:
data: {
  linkedScripts: [
    { id: "123", name: "setup.sh", path: "scripts/setup.sh" },
    { id: "456", name: "deploy.sh", path: "scripts/deploy.sh" }
  ],
  scriptContents: [
    { id: "123", content: "#!/bin/bash\necho setup" },
    { id: "456", content: "#!/bin/bash\necho deploy" }
  ],
  variables: {
    "123": { ENV: "prod" },
    "456": { ENV: "staging" }
  }
}
 

Aanbevolen volgorde

Awareness â†’ hook maken om LoadScript-nodes te vinden
LinkedScripts opslaan â†’ naam, id, path in RunScript-node.data
Content ophalen â†’ backend endpoint + hook
Variabelen injecteren â†’ eenvoudige UI per gekoppeld script
Script-executie later â†’ backend orchestration
 
