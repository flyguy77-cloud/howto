Een gescheiden database model voor de tabellen status en logging
Watchers in combinatie met Java concurrency thread pools

Statussen veranderen per row maximaal 5x
Logging kan 100+ regels bevatten die constant worden geupdated in de tabel

Watchers binnen fabric8 draaien volledig buiten Spring en hebben een eigen callback thread pool

Java concurrency threads loop ook buiten Spring om, maar door de Hibernate -> JDBC -> database locking en versioning probleem waarbij watchers schrijven 
tegelijkertijd naar dezelfde row in de tabel, dit geeft locking problemen waardoor een van de schrijfacties gewoonweg niet doorkomen (deadlock) zonder te 
rommelen met versioning en transaction tweaks 
is de beste oplossing een scheiding van de tabellen met een one to many relatie

-----
Oplossing seperation of tables:

twee aparte JPA-entiteiten,
twee aparte repositories,
en twee services die elk hun eigen verantwoordelijkheid en transactiegrenzen hebben.

⸻

Principes in deze herziening
	1.	Geen @Transactional meer op service-methods – we laten Spring’s repository zelf voor korte JDBC-sessies zorgen.
	2.	Volledig append-only logging – geen locking, geen rollback nodig.
	3.	Kleine en duidelijke services – puur bedoeld als facade naar de repositories.
	4.	Watchers gebruiken Fabric8’s eigen threads – ze roepen enkel Spring-beans aan, zonder dat Spring transacties probeert te beheren.

⸻

CREATE TABLE job_execution (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    job_name VARCHAR(255) NOT NULL,
	job_type VARCHAR(50) NOT NULL DEFAULT 'SCRIPT'
    status VARCHAR(50),
    message TEXT,
    started_at TIMESTAMPTZ,
    finished_at TIMESTAMPTZ
);

CREATE TABLE job_execution_log (
    id BIGSERIAL PRIMARY KEY,
    job_execution_id UUID NOT NULL REFERENCES job_execution(id) ON DELETE CASCADE,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT now(),
    message TEXT NOT NULL
);

1. Entiteiten

JobExecutionEntity

@Entity
@Table(name = "job_execution")
public class JobExecutionEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    private String jobName;

    @Enumerated(EnumType.STRING)
    private JobExecutionType jobType;

    @Enumerated(EnumType.STRING)
    private JobExecutionStatus status;

    private String message;

    private Instant startedAt;
    private Instant finishedAt;
}

JobExecutionLogEntity

@Entity
@Table(name = "job_execution_log")
public class JobExecutionLogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "job_execution_id", nullable = false)
    private JobExecutionEntity jobExecution;

    private Instant timestamp;

    @Column(length = 4000)
    private String message;
}


⸻

2. Repositories

public interface JobExecutionRepository extends JpaRepository<JobExecutionEntity, UUID> {}

public interface JobExecutionLogRepository extends JpaRepository<JobExecutionLogEntity, Long> {}

Beide doen hun werk zelfstandig; elke repository-methode opent en sluit z’n eigen entity-manager-sessie via Spring Data.

⸻

3. Services (zonder @Transactional)

@Service
@RequiredArgsConstructor
public class JobStatusService {

    private final JobExecutionRepository repo;

    public void updateStatus(UUID execId, JobExecutionStatus status, String message) {
        repo.findById(execId).ifPresent(e -> {
            e.setStatus(status);
            e.setMessage(message);
            if (status == JobExecutionStatus.RUNNING && e.getStartedAt() == null)
                e.setStartedAt(Instant.now());
            if (status == JobExecutionStatus.SUCCEEDED || status == JobExecutionStatus.FAILED)
                e.setFinishedAt(Instant.now());
            repo.save(e);
        });
    }
}

@Service
@RequiredArgsConstructor
public class JobLogService {

    private final JobExecutionRepository jobRepo;
    private final JobExecutionLogRepository logRepo;

    public void appendLog(UUID execId, String line) {
        jobRepo.findById(execId).ifPresent(job -> {
            JobExecutionLogEntity log = new JobExecutionLogEntity();
            log.setJobExecution(job);
            log.setTimestamp(Instant.now());
            log.setMessage(line);
            logRepo.save(log);
        });
    }
}

Spring Data opent hier onder water een eigen korte transactie per save() —
precies genoeg om één write af te handelen, maar zonder langdurige sessies of proxy-overhead.

⸻

4. Watchers

JobStatusWatcher

@Component
@RequiredArgsConstructor
public final class JobStatusWatcher implements AutoCloseable {

    private final JobStatusService statusService;

    private Watch watch;

    public Watch start(String namespace, String jobName, UUID execId, KubernetesClient client) {
        this.watch = client.batch().v1().jobs()
                .inNamespace(namespace)
                .withName(jobName)
                .watch(new Watcher<Job>() {

                    @Override
                    public void eventReceived(Action action, Job job) {
                        if (job == null || job.getStatus() == null) return;

                        JobExecutionStatus mapped = mapStatus(job);
                        String message = extractMessage(job);

                        statusService.updateStatus(execId, mapped, message);
                    }

                    @Override
                    public void onClose(WatcherException cause) {
                        if (cause != null) {
                            statusService.updateStatus(execId,
                                    JobExecutionStatus.FAILED,
                                    "Watcher closed: " + cause.getMessage());
                        }
                    }
                });

        return this.watch;
    }

    private JobExecutionStatus mapStatus(Job job) {
        var st = job.getStatus();

        if (st.getSucceeded() != null && st.getSucceeded() > 0)
            return JobExecutionStatus.SUCCEEDED;

        if (st.getFailed() != null && st.getFailed() > 0)
            return JobExecutionStatus.FAILED;

        if (st.getActive() != null && st.getActive() > 0)
            return JobExecutionStatus.RUNNING;

        return JobExecutionStatus.RUNNING; // default fallback
    }

    private String extractMessage(Job job) {
        var st = job.getStatus();
        if (st.getConditions() == null || st.getConditions().isEmpty())
            return null;

        var last = st.getConditions().get(st.getConditions().size() - 1);
        return last.getMessage();
    }

    @Override
    public void close() {
        if (watch != null) {
            watch.close();
        }
    }
}

PodLogStreamer

@Component
@RequiredArgsConstructor
public final class PodLogStreamer implements AutoCloseable {

    private final KubernetesClient client;
    private final JobLogService logService;

    private volatile boolean running = false;

    public void start(String namespace, String jobName, UUID execId) {

        running = true;

        // Vind de pod die bij de Job hoort
        var pods = client.pods()
                .inNamespace(namespace)
                .withLabel("job-name", jobName)
                .list()
                .getItems();

        if (pods == null || pods.isEmpty()) {
            logService.appendLog(execId,
                    "[WARN] No pods found for job: " + jobName);
            return;
        }

        String podName = pods.get(0).getMetadata().getName();

        // Start de logstream van de pod
        try (LogWatch lw = client.pods()
                .inNamespace(namespace)
                .withName(podName)
                .watchLog();
             BufferedReader br = new BufferedReader(
                     new InputStreamReader(lw.getOutput(), StandardCharsets.UTF_8))) {

            String line;
            while (running && (line = br.readLine()) != null) {
                logService.appendLog(execId, line);
            }

        } catch (IOException e) {
            logService.appendLog(execId,
                    "[ERROR] Log streamer crashed: " + e.getMessage());
        }
    }

    @Override
    public void close() {
        running = false;
        // LogWatch wordt automatisch gesloten via try-with-resources
    }
}

⸻

Samenvatting
	•	Watchers (Fabric8) → draaien in eigen event-threads.
	•	Services (JobStatusService, JobLogService) → simpele façade naar repositories.
	•	Geen @Transactional nodig: Spring Data commit elke save() zelf.
	•	Geen ExecutorService meer: Fabric8 levert al non-blocking log- en jobevents.
	•	Database-model opgesplitst → geen locking of stale entities.


@Component
@RequiredArgsConstructor
public final class JobStatusWatcher implements AutoCloseable {

    private final KubernetesClient client;
    private final JobStatusService statusService;

    private volatile boolean running = false;
    private Watch watch;

    public void start(String namespace, String jobName, UUID execId) {

        running = true;

        this.watch = client.batch().v1().jobs()
                .inNamespace(namespace)
                .withName(jobName)
                .watch(new Watcher<Job>() {

                    @Override
                    public void eventReceived(Action action, Job job) {
                        if (!running) return;
                        if (job == null || job.getStatus() == null) return;

                        JobExecutionStatus mapped = mapStatus(job);
                        String message = extractMessage(job);

                        statusService.updateStatus(execId, mapped, message);
                    }

                    @Override
                    public void onClose(WatcherException cause) {
                        if (cause != null) {
                            statusService.updateStatus(
                                    execId,
                                    JobExecutionStatus.FAILED,
                                    "Status watcher closed: " + cause.getMessage()
                            );
                        }
                    }
                });
    }

    private JobExecutionStatus mapStatus(Job job) {
        var st = job.getStatus();

        if (st.getSucceeded() != null && st.getSucceeded() > 0)
            return JobExecutionStatus.SUCCEEDED;

        if (st.getFailed() != null && st.getFailed() > 0)
            return JobExecutionStatus.FAILED;

        if (st.getActive() != null && st.getActive() > 0)
            return JobExecutionStatus.RUNNING;

        return JobExecutionStatus.RUNNING;
    }

    private String extractMessage(Job job) {
        var st = job.getStatus();
        if (st.getConditions() == null || st.getConditions().isEmpty())
            return null;

        var last = st.getConditions().get(st.getConditions().size() - 1);
        return last.getMessage();
    }

    @Override
    public void close() {
        running = false;
        if (watch != null) {
            try {
                watch.close();
            } catch (Exception ignored) {}
        }
    }
}


@Component
@RequiredArgsConstructor
public final class PodLogStreamer implements AutoCloseable {

    private final KubernetesClient client;
    private final JobLogService logService;
    private volatile boolean running = false;

    private LogWatch logWatch; // <-- wordt nu beheerd als resource

    public void start(String namespace, String jobName, UUID execId) {

        running = true;

        // 1️⃣ vind bijbehorende pod
        var pods = client.pods()
                .inNamespace(namespace)
                .withLabel("job-name", jobName)
                .list()
                .getItems();

        if (pods == null || pods.isEmpty()) {
            logService.appendLog(execId, "[WARN] No pods found for job: " + jobName);
            return;
        }

        String podName = pods.get(0).getMetadata().getName();

        // 2️⃣ open logwatch (Fabric8 maakt zelf een I/O thread aan)
        this.logWatch = client.pods()
                .inNamespace(namespace)
                .withName(podName)
                .watchLog(new LogListener() {

                    @Override
                    public void onOpen() {
                        logService.appendLog(execId, "[INFO] Log stream opened for pod " + podName);
                    }

                    @Override
                    public void onMessage(String line) {
                        if (running && line != null) {
                            logService.appendLog(execId, line);
                        }
                    }

                    @Override
                    public void onClose() {
                        logService.appendLog(execId, "[INFO] Log stream closed for pod " + podName);
                    }

                    @Override
                    public void onException(Exception e) {
                        logService.appendLog(execId, "[ERROR] Log stream error: " + e.getMessage());
                    }
                });
    }

    @Override
    public void close() {
        running = false;
        if (logWatch != null) {
            try {
                logWatch.close();
            } catch (Exception ignored) {}
        }
    }
}
